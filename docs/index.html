<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d4d4c5364b6afb3f7c3e44542f6e513397b41928aff8c1c010957cb9b1da7de9a4117f615983ac3469e70ab270a84a86bbf9e43db72d635d6650b568e521de1d5cb495f7abbabec629e47cc5dd1a47e99c254ac353efe64ce8706b913570a48a39353a4935635a13551ab88fb1acdfe0fd0e006f8d91750223742ea4bd562b31ac74d863c6bcca34e1006fa77cd5a5f38ca1a779a4e1f663a7510ed2e6236f3f20f5b2f21f37ddbd015e745d5590b916cf30d7bfb5c05b630b10995701f849ea4857c1f49fb36e2d84c79a6d42d5f2cf082460bd36ef54ebd3f83ea940d34a24a872ed06021447bf69f13d27b9c70591f1b057962d763393dccd89ce28ebab88996145a3bda30082d150e267f079130bdcb3175fa5208f7c230656d283af9685403e403ebdd652d7815e418aa7c40b5c84cfa198a579948a496b0b3b0539fb5e98fca3799354c9e7f882bcd0b44fb4c1273f19ed916b4899640db8c092026c43ff529d4951454a07eae370c51f821b35f18347438d5e9943e8e05a0d690a9a21527feb235d117e292f1643b17956cebb659bd25df14e6ae27f7cae2c6a79d05b19c5184d94020517ddf7910f6b4f0141fae55da511bb1ba3ea78cbfc0af90e688991d411de7b17b402614d76a2c637a1014909b52d0de170a52011fb7d71072c80a1485de368a03283d7c8b83a7bcbf0585ecd20842fb6e026e0a02631aa6a7a5adb19d057cf597a154e7fcf95e10997076cce452f54b5296996bcb312004e0cd9a3bab38fcd5f91278683accc0be58156ec8e1d4ad2891c2b6dc32855fd0d6aedf1dc411d3f111d3eb4c8cd8c6a78368544fc401bdc87c26c042d9cc111480480219995e7dc2aa57f2cb6d162b6056111b99e3713886af65a57e8fcbb497fdbb5c2d0526d4139c803313cee25b3c5d63bab8f3c262d7eb6992864890d7ec42f280c2f34850fe19c1d1c2567370660cf7b85a52867cb291c23b338d26e5f2decca097e851651e135b8f16ca04273aae169354c22adf7dca7e9505fbb003db7eb162eb7efa6c6152a5a595b8c7dfe00d7f85b51bb32bf91e8362f41a7e542415dec15d842599a531d262028d0167078d8133e059dff201bc89db2d7f427e3135f5e4eafd54735973208c2825a8878678cff71f79b25cda03db867cf99b1ca99769a98a4c6beb448cc8aaa086dd52cd649748c9bc165222c11628fafe0de55b1696ccdab4eb1696bf56bf228a90b08c25c25825c9e39e4854e23ef4a3122c1759643fb2d8e155caa5dcd941f14b3111068451eb4ccf552cdcc093cf742cd77173ec70ab1e036e30f580672f1d1977c9fc36d6985a2f1dce6b4d339cc5a9ab632400adb4874d50cd6781a55a8bf3512399965d4c7b7a1a224097f7256002d318cd0a1ba10cfd9095e6b64397ddbacf28b17c80dfb9358395a7138fd7d32eb715a55726941a7f0d1bca1667d7e8e1048ab13ee2cffb346268837382a8b495e4c6532824b1c38c88cd50d0555a3a9964acccea19925af243973d092c33a2fd48fc6f47bcb4c728b9fd68c1527e7437b84c9aee7a0b258c567c7e9df3375cdd8df7abbbe0ee822688d5b8f97ea357bd30f58d57482dcbab878699877da6f8834e185850903ff58fe8943a6191fc2c94e1d135f06f022d95f04255d18ca6b176a5031e88bd7fe03b1d9b0d6fb621ac1fa70d950e68def5d721089c80982157fc9a4e17b551cda3446e466f2a4f6349512ece69eb5292534d142780506e3537c0dd87cc55be903ec8e2abfac152c18355c28dcfed475728aefcbd4440432e835c0664a7e487279c4a37453b2e81842ada9fe774f33acee18e4c99fd72292c8c76475bf4d709844e7b2b803c2f8c7bb366969555ece942aeb1cfa7cd259bbe5e9357f89127c360382db5c26fe4edd1aa6a358a74e6ba9e79bd50988e01329eff608b1d483cadbe7aee7c74b7878ead51a28034836144954f08280481dfcfcada817942e5ac09fe042a1391a64bcff1339d43a4278734bd1b8deaff34896552a0b74a0543c0bdd1c320c33bcfb9a10464211afc7ce48d2a43e159fd43d2c90de069bcb18746d4fda967003a9652abf89906f9d949024cd758bdf09ef06cceb0a9282c8b32493d05d8bee9514fec5ef5f1a9cc6f09339e1f27ba84dda27a08da0649ada97af7e501f5bfca5fdbde58f3f575144ecc18e015f88174b18df2124b6a7adb9fa5960b84e6a9c219536983e3301852afb77258d973f7c330d5bf6c0cb9211be12380ac318cdb9b513837bccdb7abf5ff152b2efc7bcf6a79a7919863205208428038dd06ed3a6bd6f3800aab7b78d0d566896a1b678bd0dce7a7cdf279a838c0b129174e725a50e1e8117dc0210ada1e4b247bb838d8fbab1cc3517e2d2674ccf8f7cf913f781542528a8267a1d5de5423f221f6f89c090484bc1c1c7253d7b7f12b765dd875dbcc4447c7a7d41d0e06d15407b78ca3b17ec227a9b8b692710ea6bf9ed229b89f606889b83365329c30b884dae392be994bdfa8a1889f0fc653b51aa9b15c715231c461e4607d0efe72bbb5fce06535e8356118d8626bc76297015f9dc7759ebe99688a1cf2616e7d461796f19e8bf7eea379316141fa6bc7bdae8158035327ecda6bbc575f14e31108315f2b6e83beaf3226c4749ae432b67303960a8e22597d818e3254465c34eb1c84c77386d57eec362ae43d273d8fe3e55aec6c89a496e10c6dc5123add903bb0fe5fd98fb59c655158dbce024ab40219e9603ffa8b1bf5711765557f203f48233969fa9cd3f96519fc8ac1b23482ee7cb37088fe0b2dd27ba8db16c7935067f3c7d16ea79f93ad3aab971c74e12a5306684548f6fadcf29125932ef68acc7818c5f8948e2fe44d77b55f1c5a6c8ebd4939312a41babbbf669e269ee09d04823824bc44f31cc39d224315a3c564074b33c202dddc29cf2fbac6cff8868b7af1010db5a8bc3ab82c6e6a5f1cf1c4d0769afccb878bd702ffe44bd477c0838a3b138601f7596042fa9ccbce1e88245562532b507f16ee4b86b42371b779126c6724c29af0e0fe8ae5b347e954026758d27c74b5580dfb12345c56efece6298ebebcba473159e6a851e3191e9858d8dca932766d9c1a0477bc58308ad064efdc1a0963795ae846697f3148cf7ef0181f0f60a39aace473bc22f5b4ddc145274541e31ef89603652dcad6a3e34220ce25455ab8ccd644628be0a49346f4b51afa04603abb4edb43d2cd1f2404baa83e4be78ea41dd0684acb6c202a6d352b069b9415447d2dc78b94d4cd50e8024ea2145701de715e1a61770638919a234f28a13c292c27750cbd448ea5467bf749603fde6b65cbf2722e23f61c2aee509279d7ec4dbe6dcf8290666e672496bec8aa881ff90ca62a1ba809831db1125ced66d0bb5ebb2d76ff481783ed2cb1e1a3d7e7d6c74518d003c401d6afd812afa6b8a5053fe96ec5b76898b44819e184f0358681d04c9400fc52664d4dc6f83e7cf4043748a3071cb93b70635411540b62d488ce0019934bb978b550cb6929897dccd57ff339cffe7e70f87bf185ca8d9d16b71b1d5e4232476ed483c4113167c3c1ad377de297edceefa97697def3a4d9c8d27f67c3c08c0d7567b9eead92c074db1b3e861e784a2f077f0fb61627e1646f5e515f89bc6e7f0a4ec0b8fae2a8ff3f9bce788d5cd2c99093eb58d3e59ba6faccbb406c242d08fce5e7ec081004052d8ebeb383b213d1bf17900d0cf16b4e14497784bfcf98b5406e0d23f566cf667605d08190f5715aac6c3c87283de1c2e4be3aa5e61670270715765215c13f265e98cc874f9d40400da0d8b204990e9ca74553298f8cc69c03c70a55ae793a575b60e4f3cbd3b42e721e9a6e959204fb88b5480e79488d83003374d95f2755fa18dfc854c340fc5cc03595e88c5c4b8af1f28657bd376738e17c141a1637d72b4e48ac9b95dc149b71bc04df00edd273f7b0602a60c685bc871938d49928b1efee9eee4be00f7f890496d6d716b068eecb52bfc08e1d730d981219eb2503d30ee627ceedb54cb5a887d29025c46085054ea23a661f9f037096e3182c184788f7c435804e3cbc542ff534ca1e7e1ee9c573bdd2cd67a65008ee2f7d4266f16d3a884fc17393de904106c5eb58a53774a4ef729f74988e4898aef522b79f95a8799e2a0ee008615767092cf35c67bc2b79543761708f93cd5d67dfaa0aa73e03047171090a6478805f85dcba6a3cf0bccc84bb340c399467b26fb86182a5520f2daf2580ae6780c2ef123b07ce9ede56d2f68992e4c8b3f1f6301c33d797dec6270231fbd31a67d74767f24a37d8dfa61b6f497d9ce3ace9b0ca06310aadac1b74454b77f8c0741c07631bb4b1206a5465194a3f5eb1e3be3ebfcdca97a47d0f0a9f115c61ba0ec20ad2491277c52d98a12b339908a90cbfdf8854fe5b30c785e42565946c8f8daeeafbcaf239587aebffd4245ecbd7e4f9906cf4ea53d90e56052e1b40ed49f509dae5406d3787a6e252d844123aeb913ac5ba882bd07fd4a600851ff547fa9e4a2674ef4e4ccddec29cbfe8626ccf0dd5e2aca30e9d498f67ce61ef9fed76dadae0b68a73dd3c15dc8f1fde8d443d3842daaf3cbcf53ad58ba982da0c1ae6e3dc2479933ba519f5ae4b2511e941182d501175f2c5d5aae0a3865fed01f6b27eddce14bf667f3e03b362d5da33a1038164ba13c0346dd1ad56d42dd0587b9ed06fb9ad092533a635000677d8e3aabaf800e442255fa9352883e8d4eff153e5baa57ddb073eed62af32b432c859a4b8b9d49ddf9854dbab1b7bda280d3a78cd7c92f5ec994b9c1d7ed7beb7364c2c1b20cef317f45f3533dac5b91c8c6e0f85d0938fbce6d6846b6c18cd3fc839bfeb9877e1aa4a11a600f13226a1a14f5925b9239867d9dd5fee185b65bb895d51e86d791d4277ce88c3285e2cf663716e51994b183681cf8073f26d756817fad53144e2d24316835d36fb2344c2cac34a8881ef4cf3f55cb63a138156a032dbad195cfc063fe7bd1b0c2fecb0d76540e83eb840065c5e5149ae0cd5a9d7b74cf03573a175c6aaddc0e0072408bf9ef039f03771ff34d01c1b924bb43600c1f249a6e43bf2a531edcbab599f60de03be405d18110e52d67bd8d453e4d66d7c3e4bde033c49ca98a1b5d164c007dcc21554bf57b1848f69a244b03420e21a009dd0b15e7def0f7f770071979428ca015ff14748fa4988ea7addca61109f6c4427e49209640f9b2cdf5304e29fca3cf02ce2a9723eebe52d88be8a957249e191716e27f120e145357b748a9ac4bc4b6c1778697bbe8dd0501f57d6976ba8bf3ba96c85f6d0cbb3b85c90da7c39c2c17861f54a942137637caa9a2bbf930684b00f89de64477ff7e0d849ee8458366e2cd5c429ed46bc95cb9df42a718a3960372618f72ad6ec5af947fceccd775a01a8661947bb16f8bf8aa948e5f01747ec41e2f65d87fc96415cf1b178a25db3c31030cea658f6acd5fd1000e094d0d21c5dab5c53e333503a14c48cc51a2b10efb96f706d64115ed55e0286ca29495dc04b5ea46cd7a123c46753b6a5713ee7591e20d602933d29977285d98291a33c79d96afef8cacc246760e4181bf3e381e35ea52c098289c44fdfb9b453854de4951b09743476b7a6d022f4f74566d4de75acddd28227e45a46fef99811824a3311636b94c460107d7683d73844567152d22aa93c37d5aab60fee90b9496da78e390077deefad81d7caee564de5bd5483ff8518f0b0d3efcd17e65ba0d997d13c4438efaf3f15c3985c881d65a5553ea57bfbf948d6af101359467627f98802c63e3b718413b3fe97f8a33259c9569badb2f4e051acac35df384239e8aa1bc77be846b5552fd9e173c8e718f39037bb3fedbdb581c2a20e3449882f10b4d2dbdd8238a29021ffedfea688d38859c95af3a3c558568c2a9d44acbc8681d918b5d0e384173972ee702c4735a7ebb1097e69eca4d7503b8b9de88289af79d2dcd10051816125c2c86bf01b26c3f3103b9f15a036dd93ad804965300f173e77319670568c40fe96dad573fd0057d844af97c8b20ab316f4f73127b8f84ee1ec06cecf0be0621c78830815011575b7f01d3b785936fc469978f7043704ce048bd8f6bfabdc990725e2a34074c56c53e866e8836fd3d79c9d78fb4a5319ac2c64c907d9ed442f21dde3437b71ba9875cff916853f2085e71fa0f57e5ad85cc9ea461fc6cae02ac9a4854c69db1c2b9e5f296885827c5fd7ad67d87b4a741e73ffaaa6578710bc609b4956bbe6a9a57ff7c925ba54bb5b6e1cf1b5b268ffa6c82dac1fbaef7400f05ce5d1e2c8a443047c661e181b9dd02cf7baaffc443db8d6032c3172960ad3af79239589ad1586c617199ac0645cffc6c1f358fbb839e728e44ea43c0d27ffdd53d6148eec5c26ac5ed49cc4979f9aae777b20ba7dc2b4f3da9f3310e91633eabc19374f3725f24fb20598eda7617b00cd293ec3b0f020da68e90ed4f0662ff29003f44f30463a5bfaefb4b5d498b1b758ce930b3b82cd263992f945ac0328e12a21d7be14b04379e8927e71b1999dde9ccdb19fb64fc870b6c6cda7cea8d8e4350a1291b666a194edaf084f03c94e904561657a0a88ff03608a2941004568c7abbfa449a53c78cd20167438e414d3ecd2b280e912355c0511765b332f0a248c52fac1a0b852e77e422b5adadcedb60ad2af0dbf512d8cdedbbfe2247e066565ca4083f4f6f966561611904301d151b093c36c476026dd0f9c7321b5a3a4dc9069249a4c5856e12e909219060474f7a3345f54b4d28593f3deb8ace5bd29ac447a4b9ba69ff783c13c3c2089ff8328d702e8588034a83894ec3d7ca3efe5fc3cc400e58acbbde610aeba94d83bd78caf36efe2e7bbb136e0933e91bcedcb58769002a5bbc5cc8049fbd1f0af448a2351bf16fdf48ad1da90ec3ac7c2a47c7dcadd3dd8dfab88124f7d8b4a28fe423466c4fff4922078e4a63f1d164cafb026aa63754fab515ef82fdc39b1d351ce2f79094e5d63c7436a5c776eb6d073b8010b9dd460575308fa623990d68aad12a75b347ae3911f255aec21503625cb33cae8b43d25a4555e8c2b99828e8fc0853050e177bb2fc8973a8443e28b2ba64174f3c4ff021f45deb0f9428f99fcbb132ec44f9bf0ef1eb0016886f40e7ffb3f1cc50f8ed5fe1aba4f64919eee67a6fdf4d8f35272f5f16a8fa533831a3d930e0b4f3b9e99a8d0349b3942cb89c61740b94bf1b2681551f4f7847965247f0ba3a171202de4a7b2959461a7f854f39315e4b332f3f74a71731c9cbd202427ed29d0d9442c31ca0b6d2c80b3276235fb3ca031a057714dc925486c8f092ac739065636a03c52a5d659c555f2620e079f5052579fbe20205e2066f399d2a4c0b6bc25fbcda882c0b95167c207a6c4ec5cb438ed50070ee02da1409b64fb45435057edac8b69f9262d0ca15446df0505070977efff9bb1101de2187d10ca08456852f5d84c688ae98b3477919a57a20300b3ab8c4e24b9ef5acb9ee560939685cd6a1dbe95c4399c6716cad11d62a21507c3396ffe88a5bdb5afa92a06ad47068e8c34907f12790b6aa0d70b44771d5fc617a3b174078a497afc1228b1df2755dece314dc03910f6c74eaff1a547da8ee60edb10e00c098bb3ede6e7dbe0b257dc0ad371eb367b4457b6bc0858202c80e488da9e15062d35b18c86feb10d4f2d65c872cb2bca824323ef293fe04a37c71b51674795db78b58af3486904393d1aace6fcb66ce73fe462a52d9213404ec7ee36284e1f5d2fe7dd3ae0e37d9fd699da7617702c0d19c72738eb51c5dc4c959d612fe49b2bc579464d74ec8000a8f063989d6a37ed7c90f563e619cbd7252904c62c58dc943980d49518fd88be13babf7467fddb723b63863fd5db3b25f60d8e248318bbfb05f1d83f85456ef7970cd41bd03c5ccaeddc71d3664541a09abcefcb6e8ff1ef9ee71a97b11a3f0261a0a5581ae3bebba448283128bf57440fa7c9a5d915f75571f887c3bd24ffdd856fdaed4507fb869b410614a536344635202cf81ccae3b5492a1b7cf6ceb3322cd7715483910365290f479290829c3b8f5feffa004adce6070165ef80fbab7db7dc7db2d322819494aa466935959cd0e601d3fdf7a76851900b8884ae4fc593d46b2df383011514080847de6fa7264d4530280899deba2c84327ca2882dd33b08f0f675802cd5ae052c0fc539ce9c56dd30d03d5e1c72cc2d73b023f92e491f1fa06ed6f6869134154f69e631ef7272fe9a03fa574ad048cf0bb99888758b32c814b5ce6f2e5bfaeae454c82ea8c06e39e3b3cd385d2533c9e6c3acf8b07f0bc5b1bd774bba693a72fccc27fa82ad69838b3cf3e78e8771132fb1542454fd86a7d208c87c0b5e5a9c805434421a325cc09ae72d3734fca61b8eddf714f7f506a734a98e583ab8bae0210075ca59116aca82f42f4c69ae829e4df069eea396b46072cbb9139c8da7903cbb84cdb8749d8aca82fcd8d101cc3dbaede536a5007c460208a55ec5f33a1e524a035c62ba7d371116ff5f693f272691972545b93c41e37880f2d42f7e8bb9faf1732612ed9d653893d64bb6e6162a24643ce86b3da99b5f332dd97c4f21163ea600d87fa2cfddd87a78899c0e5a696c2a776b08753390368acca1bcb7b75b1e6f0724c87da65728a7136e5aa2f2f9c13d7214b915cb0080176f7fb3006d488e2aff6e44d87c02522d028e0a67d2fe6968cdfd8e4ba3f301ab747ef71c23ba7424030ac14ba2c6325cb7e84030a8c8159324004cabd8627b7eb69cd6cef8a71eb13393d5d616c2820bcf9e812a405c797c9787b8d8d6d39db3b2ae03e254ba4aa1e448a681308faba1f4255938d75e10d994208624b52b7fa9ec3cbfe0d453e4f49e6e77acebd83f26e71ffc3aaaea47ad47afddd51795277b2ea8a47e9f027364af603038377f2f090d744bc4c3ef54dec1c6edb6e698e8f41d159e7ea6d6e7d83bbb91e357bc88e9f446da72b8f9f5c4e9ea52ddb9327f7d95405ee91033b573e02b153a01bcb076a879a049391137c3d5d52d30719e4d0bdb4d9b06ee04158d0f39f182569c7d481be22f239f6a611f44f98500a8c0fdb62a007a81d72e01d0d7ae0c1542f8d4edf3eb4040e9e019f398297b6c383b2bb7dec67bf069603c5e44dfeb2af48d65f83d353ccd9081735412c73bb1994a32814b51aef9aa2055f26d814d1e453eb3d21d80d979944bf07f107cb211a3819175479c36d396ce149db7a554d26e8d5b9122b0559feeef87596060a6d272e5257f432e40d49b41a559e6ca42fe83721eaddb87d169752be1ed4bb0169628b64a3820ae57e12ca5384c26dbb9bcf869ec55768cff848969f82a425421b8f7da724314188d0ed723ceb537615becb549d7738f3bfe0684db98d1157bc779714907d253b42e487b20c9758a04022f4126dd682ba75333247a44670abef253dc1d4f3f57c2c333da9948421e0d8e69f37ce98da0bcf22d0440d7f4242b579c825cc23f95c875e0b2545937f7020a8fd295f44956ac02b861268c7a4b36c6b37d18aac9d843153304ee454cac37ef463c4ad7ac2c3c98a2966bd7e4df37aaf23fdcd72b4ccb7a60e559674f3bd64026aa1545b806cd18e1b5ae4a4bb8816fcdfd20f5f6fe451626f5ba8ff202dbdcd003c5bd4a02812d7015561989a9a376a56dc1ab85f5ccdfddab7383aafa604cd0650374bd460ca2c6c332238de9aa8135e60fc949d7bb4602e83316540b89f2de2808bc747be85d8dcd9dbdc5dd5afb713e0c26fe4c2229993ffe2ec8d15fbe797fe10f0cd29f8d021447ec2f58c6c7db76be4f7f31addd62fceaf9384983cf6255d6553e24fc577922e1f13badf3f0149e566645fa455a8b1afa01db84e00200fe7c082cba97d95a2edddd090cf485e6c0c3fa4d065569d4db171efcc8501ca72e0590a2f7f0d86a40e21a163a88f2e58f190f5821f9f5c40fb2e0f50fec76698d87dfd700ffdae379ec8baa0f19fa0fc3ea8d2ad5f6338bfd4e398bc855cc7716f0f6adcb8bb8f5e769916dd154a7fc51bc6c7057dcf85ce0a975372393f633b38616dc3d745acee4244813fa954225f01906ffc598b1ed2a296257621a025d0a8608847e83089df531f16696e98b8eeb212cd9e35a7ee6b9c1418c3ce7d2fcfb7e25b40da7aca0c47c6b88335ea0c418fb9a555ba876d1af1e04f6a180d6338993949cda90e866743853a173970cb545629ffa579e91eb14bea222f690858f60d1fa0c53782e66ec2b395c9d421577b026494b2b712034e9192fa8a54b374f90bbc89fff5cb36975bc03a90fb76f5b06fd37b35d0139683c133a192f8fb3b4d0cd2adf72afba868e41a8eed845ce7d4f9fe9130afd7b517bcdbaa882e1b38c796272e27b3c128f96a512050128233f28f39d8780203f744f5c84a74aeff86061b631ad61a3fa522b469eab32c84721a09335ebac236356505143ec41ec47f48b94e0c97c9b422def430d89f6c6bc258bfadbc1b7fbc34f18fe1468e84bc7bdf424e9c876f755cbc3856e0982563f37f2b64464206ee988d1599fafaa9a88f11a2dcdd57b06f88179b2fd58cb1c4e1694c9f5204f6dca0dd315d32f74fb1435fe5dee984385d48c0c1f5b65087bc0f1be686e55399ac47745a69426677671b24e324c295a12bbdba2a3b8288daf960f448621c494143745944cd9b22930459b6a3341398e77fe685127c73165eaebd1cb6c6dab8e24faafe3e3ee1571945fe2e17eb1457fbe5394659b37328cf089531b1bd106f7606cd0420958f466d5ef75c8425821d1034c9ce851179942fe9a1d5dec48f8db818226a957bfb3fc3161b7b258fe044024dd3378c5e9aa2e7f9287a478ee52bd9231a3a0c2952aca1c599b1db8f32adc407cf4d327c60c4facf46af3605c5a14b2cf6f0945e0b07e7d13d99def60e9fee933d074c969f7ae3ad72c09168e264759b32ea002d099f26550a0f3a06a42c83b2353bf251016941e8d0e0ec080bdcaed08e0a48ba545977b529ba773e9fa5e5a70a4f9d3908f2f0ffe35bad132dc6094e276d13941fe8cc13e3d5f8d8a1e0f1e405e270ddfb383b465540c29717d05dcdebbf36423b104b2434e3766e73fa491db3286800fdf5b7282571089aab5e1ffd42b89449dc5e459f0841de90255057d0696666a8b012cf31938187cf0c78b476302a91d2bfc9710b7ee2799cb55d69ce495efc1a23b0a884b947fd997fd5528778aee0b488c24f40ee61df8af179be1cc96586a2c3bb4051d36055b705371f27b13f664818cdbae04d36807ea759299beb84227b94b3dae009b92cd4f2f91025e49f47e5b914867f67fd2c9f93d84f7344508799f4e2a3886b4b3d82f2557ac4ccbe599ad801639496f278f395638cb60f4445e3490682c1b4a585c82ba3206f2663ea786d29f1b14a48d23661f4d318561706234d80697862ef0d5f9dd8e1a51383ae1660daa383e8d13171dfed949f09c550fa02d9dd1157053c1020addbbc23dcf17b141638a7bc5bb164709714ee23de382a236356b05de61c0d4dd48e927de6b43ea905039a45321bf0c67f431af888bec9aa8ed137b984d67c41cf990d7bdbcb6f4e8f9e271485921707df64948a7f381e26314f400d64ffc976d78be53b890795a8610276382877d209cabdeb9e8b787950505f38bf0cefce8ebd8ced5bed9016cd64430af0316d7d2226c3ed1ada0df5a41edad887902ce0fee744e822114f55d72c753ac2d6585f34a80381e3b41c13ae69e27bb09e8b257802802378df19b9b94eaaa298e330c9551b219583f4e0e4863e80310be591bc3b2301d5eee2aaa945c9866a720bd5a5087506b18cb89261e78274e69e4f2f33b04d872248c6670b58e8a769885921513292dd20f4105639bb0fde8d2e54bf95c0dd3c117de3d9f0667032d605aefe1cb0a9b5526bb52611e848de19134be5c6438dbb9ae6ff6bb875d004c826a0aca262b1fdbc1f585b8b07fd956e97acb1ff32e05e4050a7f7d1bef8eeb9a7e5417a1c30112d4b47ca53cc5133971c63d88338c2e6742a74670ecbdc0c9f6cba210863b9327fddaa3b3a595d4eeab76bf55dcafa8894510d4cee65f151f9cc386283bfa07cd41e6f806fb02d0658751745a0c2c9a8d06623f79335403a5c3bbdb6630589c1177173330b190c4d084733f3fba3636c0931230bb0f7a0d154945c7f7d5275925b99861122778349346a53bcf9fcc632e2c7714e380daf4cbbb13389d4308dab0543255d7f8ad03a853ba7ffe5606f6537ff1439e702631c3fe99c85f0d68b7479873ab0c701e9a4e438366d64b217e1d79856ab26cf12494b12b7a2ec2e60a729140cd231845ec474ffcb7b39bc8053833114bd3becf869c1511685db714122cd4ead84f2874d2d25d898f45509d576afd2e1d4f6a5204f3fe051b9e7f8565aaea0df16730a1146a5190c7ffb0004a00489ccad7e85d211aabae4eb46e7562c8f3dbe929a4372c56c3f8533061be91986b172462d228ed686eb5a82f6503ba924d2f3d765da4710dd58012fcfb1dedb6aec9d21396ff394d9779ef4e01bc2c344f8a60952b118a66e33ee2759e7e1c5766bee61541ef39b4fd3a27f39f496a2307e7a9a75337185e513bd0135d656809bbe1b1698587166da57916286f1e0141a8954a71cbbfabc49d3aa335533a0645718c66e4b571dce3cce1429e10a9f1dc7fd13febc3663710d566d406d5d3543c392b509f27630bb7ffe517df865a0c1d8434783d47da99d5566f3e2481c9df3a515a930a73d458b35413ee38fd28478e7237ca76fa64ef86074360a783b247c4ce3826ca700eccdef580f97e9d56a5c9f18d2c924d41e62cfe8cfcbafc26364f1052d9170f7f10b5121ed51caf0e7846ec385ecf9a94b899e7580a3f1ce4526dc35a7281b3bc150dcf798c83dfa1c755432cb80066e7a20478913b11a1c9b63f611b62953be704c12677c7a06d156537336b4b63432df2bbf9d2db8a71dabf1c1fbc019a99909911b296dbc78dd333ca56c1c48ee62aa19caa4b01cae4e24a28adbf9542fe8fc68024e30cdd4417eb4d30f54dbad1707c710edd895979ade37145d3e0f1bb8aea25878bac457841265a60065c95183107fcfd3e0d487620602c3d657f25eb8635cc9acf9e5414d884694e99e16acda6c73ee41db844db1be2f2fc45adca36f542c17cff7b9447baf40bf56f2879b936d5d6a6b38e701ff1ff13cd734d23d2b619290ceaf93ff78404533fd6307d1bc4bbe3a0f026c38f6e77bd0ee604462e42804af9eee40974088d1359b6a3e19c23834f84ea84c8fdd3be5cd29f6e230d2baa97bc0186daf62e3e628c35f01fd6b71d5aaf8c318ca4c697d6e26bb29d1c4ad4bab7f460b698509080d7972f252c22ab1f2280dbd333c04f59da6a1b22b1df1e5fbf0decbcfca306949aa8f7e0e53a3f90ef06144833d28b19b061cacd85849c7e047f158661133413b6263259cd024575815abf831478886f7008ef0fb81c7ea04cd7ae76acf64281b69eba5a2a16719f370df7540630a911675e7f01853c6591b7301c636e831788676e8e932bb4a79cbe05eafc894c450c6b81dac3fa1d48e6b4beffb78671f147ce148e35552cfb8fb5bcca22bf5a4383078f104407f2b70b032d1df01afe062720e8b211ca70f857e16a9fbc095deb00b5614f9b32b51b849b064cbc7f2479adb024f651e607eb6961a334fc97ecb799e6a003877d3172c81578c83d91cb506b628ba94035be483396e7b1353456567a7317ad0184eacafbe2fee2c26275bc1be642b5a53010e0e16d6ed3ec783488168a86fe18f0f69f8b7d2c06b9eb058c9a1446a5da9469b034451c232506d890b09ac825610456d91d71e3a6db9ad652a7895e6d5e19c5b4994c9a396b692fb8dff9e5a682ec367d20f0fd3fff2245bf36c172401918b5aa0126664845bf196af7955556dc6750d8b16289a376ea85e6a262037dbb847dec4dd1d249645d2333438db5e5a19ab937ffb7d7a011463cbbbd15f930de63b9c8e70482c1d4ae6b769764b895362d5d5dacf0e6c08bb52b3887b11585ec2a25979728f50c8815d3ec5778ecfd524c3e0ad9a50f05af903756757188639875d4615f6d402d98cc4feda9550a729cf208f8ce54c6e004bf436bd49b41bf43b63c54ec508e5c10b8b3803428cf5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f83efb99fd9d56a0461baafd137f5560"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
